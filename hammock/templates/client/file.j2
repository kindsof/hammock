from __future__ import absolute_import
import requests
import logging
import munch

LOG = logging.getLogger(__name__)


def url_join(*args):
    return '/'.join(arg.strip('/') for arg in args)


{{file_class}}

class {{ class_name }}(object):

    def __init__(self, url, token=None, timeout=None, headers=None, retries=None, session=None):
        """
        :param url: url to connect to
        :param token: a token to be used for requests
        :param timeout: timeout for a request
        :param headers: custom headers to send with each request
        :param retries: max-retries as an int, or a urllib3.Retry object, 
        :param requests.Session session: an external request session to use
        """
        self._url = url
        self._client = requests.Session() if not session else session
        self._client.mount(self._url, requests.adapters.HTTPAdapter(max_retries=retries))
        self._timeout = timeout
        self.set_token(token)
        self._client.headers.update(headers or {})
{%- for resource_name, resource_class, resource_path in resources_names %}
        self.{{ resource_name }} = self.{{ resource_class }}(self, '{{ resource_path }}')
{%- endfor %}

    def close(self):
        self._client.close()

    def fetch(self, method, url, json=None, file_stream=None, success_code=200, response_type='{{ type_json }}', kwargs=None, url_kw=None):
        url_kw = url_kw or {}
        url = url_join(self._url, url).format(**url_kw)
        if json:
            json.update(kwargs or {})
        _kwargs = {
            "timeout": self._timeout,
            "stream": True,
        }
        if method.upper() not in {{ url_params_methods }}:
            if file_stream:
                stream = File(file_stream.stream, file_stream.content_length)
                _kwargs["data"] = stream
                _kwargs["headers"] = {"content-type": "{{ type_octet_stream }}"}
                if json:
                    _kwargs["params"] = json
            else:
                if json:
                    _kwargs["json"] = json
        else:
            _kwargs["params"] = json
        LOG.debug("Sending %s request: %s %s", method, url, json)
        try:
            response = getattr(self._client, method.lower())(url, **_kwargs)
            result = None
            if '{{ type_json }}' in response_type:
                result = self.jsonify(response)
                LOG.debug("Got response status %s, body: %s", response.status_code, result)
            elif '{{ type_octet_stream }}' in response_type:
                result = response.raw
            if response.status_code != success_code:
                LOG.info(
                    "Response status %d does not match expected success status %d",
                    response.status_code, success_code
                )
            response.raise_for_status()
            return result
        finally:
            self.close()

    def set_token(self, token):
        if token:
            self._client.headers.update({"{{ token_entry }}": token})
        elif "{{ token_entry }}" in self._client.headers:
            del self._client.headers["{{ token_entry }}"]

    @property
    def token(self):
        return self._client.headers.get("{{ token_entry }}")

    def jsonify(self, response):
        try:
            result = response.json()
            if type(result) == dict:
                result = munch.Munch(result)
            elif type(result) == list:
                result = [item if type(item) != dict else munch.Munch(item) for item in result]
            return result
        except ValueError:
            if response.text:
                LOG.warning("Could not parse json from '%s'", response.text)

{{ resource_classes|join("") }}
if __name__ == '__main__':
    import sys
    import hammock.cli.app as app
    app.App.prompt = '{} > '.format('{{ class_name }}')
    {% if default_url %}
    app.App.DEFAULT_URL = '{{ default_url }}'
    {% endif %}
    app.App([{{ class_name }}]).run(sys.argv[1:])
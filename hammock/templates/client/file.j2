from __future__ import absolute_import
import os
import requests
import requests.adapters
import six
import logging
import munch
import warnings


LOG = logging.getLogger(__name__)


def url_join(*args):
    return '/'.join(arg.strip('/') for arg in args)


{{file_class}}

class {{ class_name }}(object):

    def __init__(self, hostname=None, port=None, url={% if default_url %}'{{ default_url }}'{% else %}''{% endif %}, token=None, timeout=None, headers=None, retries=None, session=None):
        """
        :param url: url to connect to
        :param token: a token to be used for requests
        :param timeout: timeout for a request
        :param headers: custom headers to send with each request
        :param retries: max-retries as an int, or a urllib3.Retry object, 
        :param requests.Session session: an external request session to use
        """
        self._url = url
        if hostname and port:
            warnings.warn('using arguments hostname and port in client.__init__ is deprecated, use url instead', UserWarning)
            self._url = "http://%s:%d" % (hostname, port)
        self._client = requests.Session() if not session else session
        self._client.mount(self._url, requests.adapters.HTTPAdapter(max_retries=retries))
        self._timeout = timeout
        self.set_token(token)
        self._client.headers.update(headers or {})
{%- for resource_name, resource_class, resource_path in resources_names %}
        self.{{ resource_name }} = self.{{ resource_class }}(self, '{{ resource_path }}')
{%- endfor %}

    def close(self):
        self._client.close()

    def fetch(self, method, url, json=None, file_stream=None, success_code=200, response_type='{{ type_json }}', kwargs=None, url_kw=None, headers=None):
        eventually_close_file_object = None
        url_kw = url_kw or {}
        url = url_join(self._url, url).format(**url_kw)
        if json and not isinstance(json, list):
            json.update(kwargs or {})
        _kwargs = {
            "timeout": self._timeout,
            "stream": True,
        }
        if method.upper() not in {{ url_params_methods }}:
            if file_stream:
                if hasattr(file_stream, 'stream') and hasattr(file_stream, 'content_length'):
                    stream = File(file_stream.stream, file_stream.content_length)
                else:
                    if isinstance(file_stream, six.string_types) and not file_stream.startswith('http'):
                        file_stream = open(file_stream, 'rb')
                        eventually_close_file_object = file_stream
                    if hasattr(file_stream, 'read'):
                        if hasattr(file_stream, 'tell') and hasattr(file_stream, 'seek'):
                            file_stream.seek(0, os.SEEK_END)
                            content_length = file_stream.tell()
                            file_stream.seek(0, os.SEEK_SET)
                        elif hasattr(file_stream, 'name'):
                            content_length = os.stat(file_stream).st_size
                        else:
                            raise RuntimeError('File stream does not have required attributes.')
                        stream = File(file_stream, content_length)
                    elif isinstance(file_stream, six.string_types) and file_stream.startswith('http'):
                        http_request = requests.get(file_stream, stream=True)
                        stream = File(http_request.raw, http_request.headers['content-length'])
                        eventually_close_file_object = http_request
                    else:
                        raise RuntimeError('File stream should be a file object or a path')
                _kwargs["data"] = stream
                _kwargs["headers"] = {"content-type": "{{ type_octet_stream }}"}
                if json:
                    _kwargs["params"] = json
            else:
                if json:
                    _kwargs["json"] = json
        else:
            _kwargs["params"] = json
        if headers:
            _kwargs.setdefault('headers', {}).update(headers)
        LOG.debug("Sending %s request: %s %s", method, url, json)
        try:
            response = getattr(self._client, method.lower())(url, **_kwargs)
            result = None
            if '{{ type_json }}' in response_type:
                result = self.jsonify(response)
                LOG.debug("Got response status %s, body: %s", response.status_code, result)
            elif '{{ type_octet_stream }}' in response_type:
                result = response.raw
            if response.status_code != success_code:
                LOG.info(
                    "Response status %d does not match expected success status %d",
                    response.status_code, success_code
                )
            response.raise_for_status()
            return result
        finally:
            self.close()
            if eventually_close_file_object:
                eventually_close_file_object.close()

    def set_token(self, token):
        if token:
            self._client.headers.update({"{{ token_entry }}": token})
        elif "{{ token_entry }}" in self._client.headers:
            del self._client.headers["{{ token_entry }}"]

    @property
    def token(self):
        return self._client.headers.get("{{ token_entry }}")

    def jsonify(self, response):
        try:
            result = response.json()
            if type(result) == dict:
                result = munch.Munch(result)
            elif type(result) == list:
                result = [item if type(item) != dict else munch.Munch(item) for item in result]
            return result
        except ValueError:
            if response.text:
                LOG.warning("Could not parse json from '%s'", response.text)

{{ resource_classes|join("") }}
if __name__ == '__main__':
    import sys
    import hammock.cli
    hammock.cli.App.prompt = '{} > '.format('{{ class_name }}')
    hammock.cli.App.IGNORE_COMMAND_NAME_FALSE = True
    {% if default_url %}
    app.App.DEFAULT_URL = '{{ default_url }}'
    {% endif %}
    hammock.cli.app.App({'client': {{ class_name }}}).run(sys.argv[1:])
